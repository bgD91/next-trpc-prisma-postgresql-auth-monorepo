/// <reference types="node" />
import { inferAsyncReturnType } from "@trpc/server";
import * as trpc from "@trpc/server";
import { NodeHTTPCreateContextFnOptions } from "@trpc/server/dist/declarations/src/adapters/node-http";
import { IncomingMessage, ServerResponse } from "http";
import { User } from ".prisma/client";
export declare const isAdmin: (userRole: User["role"] | undefined) => boolean | undefined;
declare const createContext: ({ req, res, }: NodeHTTPCreateContextFnOptions<IncomingMessage, ServerResponse>) => Promise<{
    headers: import("http").IncomingHttpHeaders;
    user: User | null;
    isAdmin: boolean | undefined;
    req: {
        id: string;
        aborted: boolean;
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        complete: boolean;
        connection: import("net").Socket;
        socket: import("net").Socket;
        headers: import("http").IncomingHttpHeaders;
        rawHeaders: string[];
        trailers: NodeJS.Dict<string>;
        rawTrailers: string[];
        method?: string | undefined;
        url?: string | undefined;
        statusCode?: number | undefined;
        statusMessage?: string | undefined;
        readableAborted: boolean;
        readable: boolean;
        readableDidRead: boolean;
        readableEncoding: BufferEncoding | null;
        readableEnded: boolean;
        readableFlowing: boolean | null;
        readableHighWaterMark: number;
        readableLength: number;
        readableObjectMode: boolean;
        destroyed: boolean;
        off(eventName: string | symbol, listener: (...args: any[]) => void): IncomingMessage;
        removeAllListeners(event?: string | symbol | undefined): IncomingMessage;
        setMaxListeners(n: number): IncomingMessage;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol): number;
        eventNames(): (string | symbol)[];
    };
    res: ServerResponse;
}>;
export declare const protectedRoute: import("@trpc/server/dist/declarations/src/router").Router<{
    headers: import("http").IncomingHttpHeaders;
    user: User | null;
    isAdmin: boolean | undefined;
    req: {
        id: string;
        aborted: boolean;
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        complete: boolean;
        connection: import("net").Socket;
        socket: import("net").Socket;
        headers: import("http").IncomingHttpHeaders;
        rawHeaders: string[];
        trailers: NodeJS.Dict<string>;
        rawTrailers: string[];
        method?: string | undefined;
        url?: string | undefined;
        statusCode?: number | undefined;
        statusMessage?: string | undefined;
        readableAborted: boolean;
        readable: boolean;
        readableDidRead: boolean;
        readableEncoding: BufferEncoding | null;
        readableEnded: boolean;
        readableFlowing: boolean | null;
        readableHighWaterMark: number;
        readableLength: number;
        readableObjectMode: boolean;
        destroyed: boolean;
        off(eventName: string | symbol, listener: (...args: any[]) => void): IncomingMessage;
        removeAllListeners(event?: string | symbol | undefined): IncomingMessage;
        setMaxListeners(n: number): IncomingMessage;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol): number;
        eventNames(): (string | symbol)[];
    };
    res: ServerResponse;
}, {
    headers: import("http").IncomingHttpHeaders;
    user: User | null;
    isAdmin: boolean | undefined;
    req: {
        id: string;
        aborted: boolean;
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        complete: boolean;
        connection: import("net").Socket;
        socket: import("net").Socket;
        headers: import("http").IncomingHttpHeaders;
        rawHeaders: string[];
        trailers: NodeJS.Dict<string>;
        rawTrailers: string[];
        method?: string | undefined;
        url?: string | undefined;
        statusCode?: number | undefined;
        statusMessage?: string | undefined;
        readableAborted: boolean;
        readable: boolean;
        readableDidRead: boolean;
        readableEncoding: BufferEncoding | null;
        readableEnded: boolean;
        readableFlowing: boolean | null;
        readableHighWaterMark: number;
        readableLength: number;
        readableObjectMode: boolean;
        destroyed: boolean;
        off(eventName: string | symbol, listener: (...args: any[]) => void): IncomingMessage;
        removeAllListeners(event?: string | symbol | undefined): IncomingMessage;
        setMaxListeners(n: number): IncomingMessage;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol): number;
        eventNames(): (string | symbol)[];
    };
    res: ServerResponse;
}, {}, {}, {}, trpc.DefaultErrorShape>;
export declare const adminRoute: import("@trpc/server/dist/declarations/src/router").Router<{
    headers: import("http").IncomingHttpHeaders;
    user: User | null;
    isAdmin: boolean | undefined;
    req: {
        id: string;
        aborted: boolean;
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        complete: boolean;
        connection: import("net").Socket;
        socket: import("net").Socket;
        headers: import("http").IncomingHttpHeaders;
        rawHeaders: string[];
        trailers: NodeJS.Dict<string>;
        rawTrailers: string[];
        method?: string | undefined;
        url?: string | undefined;
        statusCode?: number | undefined;
        statusMessage?: string | undefined;
        readableAborted: boolean;
        readable: boolean;
        readableDidRead: boolean;
        readableEncoding: BufferEncoding | null;
        readableEnded: boolean;
        readableFlowing: boolean | null;
        readableHighWaterMark: number;
        readableLength: number;
        readableObjectMode: boolean;
        destroyed: boolean;
        off(eventName: string | symbol, listener: (...args: any[]) => void): IncomingMessage;
        removeAllListeners(event?: string | symbol | undefined): IncomingMessage;
        setMaxListeners(n: number): IncomingMessage;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol): number;
        eventNames(): (string | symbol)[];
    };
    res: ServerResponse;
}, {
    headers: import("http").IncomingHttpHeaders;
    user: User | null;
    isAdmin: boolean | undefined;
    req: {
        id: string;
        aborted: boolean;
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        complete: boolean;
        connection: import("net").Socket;
        socket: import("net").Socket;
        headers: import("http").IncomingHttpHeaders;
        rawHeaders: string[];
        trailers: NodeJS.Dict<string>;
        rawTrailers: string[];
        method?: string | undefined;
        url?: string | undefined;
        statusCode?: number | undefined;
        statusMessage?: string | undefined;
        readableAborted: boolean;
        readable: boolean;
        readableDidRead: boolean;
        readableEncoding: BufferEncoding | null;
        readableEnded: boolean;
        readableFlowing: boolean | null;
        readableHighWaterMark: number;
        readableLength: number;
        readableObjectMode: boolean;
        destroyed: boolean;
        off(eventName: string | symbol, listener: (...args: any[]) => void): IncomingMessage;
        removeAllListeners(event?: string | symbol | undefined): IncomingMessage;
        setMaxListeners(n: number): IncomingMessage;
        getMaxListeners(): number;
        listeners(eventName: string | symbol): Function[];
        rawListeners(eventName: string | symbol): Function[];
        listenerCount(eventName: string | symbol): number;
        eventNames(): (string | symbol)[];
    };
    res: ServerResponse;
}, {}, {}, {}, trpc.DefaultErrorShape>;
export default createContext;
export declare type Context = inferAsyncReturnType<typeof createContext>;
